Problem statement 

205. Isomorphic Strings
Solved
Easy
Topics
premium lock icon
Companies
Given two strings s and t, determine if they are isomorphic.

Two strings s and t are isomorphic if the characters in s can be replaced to get t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

 

Example 1:

Input: s = "egg", t = "add"

Output: true

Explanation:

The strings s and t can be made identical by:

Mapping 'e' to 'a'.
Mapping 'g' to 'd'.
Example 2:

Input: s = "foo", t = "bar"

Output: false

Explanation:

The strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r'.

The solution i written is 

class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if(s.length() != t.length()) return false;
        unordered_map<char,int> isomorphic;
        unordered_map<char,int> isomorphic_t;
        vector<int>list;
        vector<int>list_t;
        int ms=0, mt=0;
        
        for(int i=0;i<s.length();i++){
            if(isomorphic.find(s[i])==isomorphic.end()){
                isomorphic[s[i]]= ms++;
            }
            if(isomorphic_t.find(t[i])==isomorphic_t.end()){
                isomorphic_t[t[i]]=mt++;
            }
            list.push_back(isomorphic[s[i]]);
            list_t.push_back(isomorphic_t[t[i]]);
        }
        return list == list_t;
    }

};




Problem statement :
Intersection of arrays

and the code i written is 

solution :

class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> setA(nums1.begin(),nums1.end());
        unordered_set<int>result;
        for(int i=0;i<nums2.size();i++){
            if(setA.count(nums2[i])){
                result.insert(nums2[i]);
            }
        }
        return vector<int>(result.begin(),result.end()); // to return answer like oin the form of [] we have to return the vector contating the result 
        
    }
};


2-09-25
Problem statement 

Code
Testcase
Testcase
Test Result
448. Find All Numbers Disappeared in an Array
Solved
Easy
Topics
premium lock icon
Companies
Hint
Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.

 

Example 1:

Input: nums = [4,3,2,7,8,2,3,1]
Output: [5,6]
Example 2:

Input: nums = [1,1]
Output: [2]

the code i written is 
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        unordered_set<int> seen(nums.begin(),nums.end());
        vector<int> result;
        for(int i=1;i<=nums.size();i++){
            if(seen.find(i)==seen.end()){
                result.push_back(i);
            }
        }
        return result;
    }
};

which is taking 44ms of time which is better than hashmaps woith two parameters 



08-09-25
A problem named valid triangle we can solve that using two pointers 

the problem statement and the code i written is 

611. Valid Triangle Number
Solved
Medium
Topics
premium lock icon
Companies
Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.

 

Example 1:

Input: nums = [2,2,3,4]
Output: 3
Explanation: Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
Example 2:


the code i written is 
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        int valid_triangles=0;
        sort(nums.begin(),nums.end());
        for(int k=nums.size()-1;k>=2;k--){
            int i=0, j=k-1;
            while(i<j){
                if(nums[i]+nums[j]>nums[k]){
                    valid_triangles+= (j-i);
                    j--;
                }else{
                    i++;
                }
            }
        }
        return valid_triangles;
        
    }
};



09-09-25
problem statement 

645. Set Mismatch
Solved
Easy
Topics
premium lock icon
Companies
You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.

You are given an integer array nums representing the data status of this set after the error.

Find the number that occurs twice and the number that is missing and return them in the form of an array.



The code that i written for this is 

class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int duplicate=-1, missing=-1;
        vector<int> freq(nums.size()+1,0);   // it will be like n+1 boxes with all zeros
        for(int n:nums){
            freq[n]++;
            if(freq[n]==2) duplicate= n;
        }
        for(int i=1;i<=nums.size();i++){
            if(freq[i]==0){
                missing=i;
                break;
            }
        }
        return {duplicate, missing};

    }
};


Problem statement 

594. Longest Harmonious Subsequence
Solved
Easy
Topics
premium lock icon
Companies
We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.

Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.


The code that i written

class Solution {
public:
    int findLHS(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int largest_seq=0;
        unordered_map<int,int>freq;
        for(int n:nums){
            freq[n]++;
        }
        for(auto& [num,count]:freq){
            if(freq.count(num+1)){
                largest_seq= max(largest_seq, count+freq[num+1]);
            }
        }
        return largest_seq;
    }

};





Problem statement 

205. Isomorphic Strings
Solved
Easy
Topics
premium lock icon
Companies
Given two strings s and t, determine if they are isomorphic.

Two strings s and t are isomorphic if the characters in s can be replaced to get t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

 

Example 1:

Input: s = "egg", t = "add"

Output: true

Explanation:

The strings s and t can be made identical by:

Mapping 'e' to 'a'.
Mapping 'g' to 'd'.
Example 2:

Input: s = "foo", t = "bar"

Output: false

Explanation:

The strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r'.

The solution i written is 

class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if(s.length() != t.length()) return false;
        unordered_map<char,int> isomorphic;
        unordered_map<char,int> isomorphic_t;
        vector<int>list;
        vector<int>list_t;
        int ms=0, mt=0;
        
        for(int i=0;i<s.length();i++){
            if(isomorphic.find(s[i])==isomorphic.end()){
                isomorphic[s[i]]= ms++;
            }
            if(isomorphic_t.find(t[i])==isomorphic_t.end()){
                isomorphic_t[t[i]]=mt++;
            }
            list.push_back(isomorphic[s[i]]);
            list_t.push_back(isomorphic_t[t[i]]);
        }
        return list == list_t;
    }

};




Problem statement :
Intersection of arrays

and the code i written is 

solution :

class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> setA(nums1.begin(),nums1.end());
        unordered_set<int>result;
        for(int i=0;i<nums2.size();i++){
            if(setA.count(nums2[i])){
                result.insert(nums2[i]);
            }
        }
        return vector<int>(result.begin(),result.end()); // to return answer like oin the form of [] we have to return the vector contating the result 
        
    }
};


2-09-25
Problem statement 

Code
Testcase
Testcase
Test Result
448. Find All Numbers Disappeared in an Array
Solved
Easy
Topics
premium lock icon
Companies
Hint
Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.

 

Example 1:

Input: nums = [4,3,2,7,8,2,3,1]
Output: [5,6]
Example 2:

Input: nums = [1,1]
Output: [2]

the code i written is 
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        unordered_set<int> seen(nums.begin(),nums.end());
        vector<int> result;
        for(int i=1;i<=nums.size();i++){
            if(seen.find(i)==seen.end()){
                result.push_back(i);
            }
        }
        return result;
    }
};

which is taking 44ms of time which is better than hashmaps woith two parameters 



08-09-25
A problem named valid triangle we can solve that using two pointers 

the problem statement and the code i written is 

611. Valid Triangle Number
Solved
Medium
Topics
premium lock icon
Companies
Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.

 

Example 1:

Input: nums = [2,2,3,4]
Output: 3
Explanation: Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
Example 2:


the code i written is 
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        int valid_triangles=0;
        sort(nums.begin(),nums.end());
        for(int k=nums.size()-1;k>=2;k--){
            int i=0, j=k-1;
            while(i<j){
                if(nums[i]+nums[j]>nums[k]){
                    valid_triangles+= (j-i);
                    j--;
                }else{
                    i++;
                }
            }
        }
        return valid_triangles;
        
    }
};










Problem statement 

205. Isomorphic Strings
Solved
Easy
Topics
premium lock icon
Companies
Given two strings s and t, determine if they are isomorphic.

Two strings s and t are isomorphic if the characters in s can be replaced to get t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

 

Example 1:

Input: s = "egg", t = "add"

Output: true

Explanation:

The strings s and t can be made identical by:

Mapping 'e' to 'a'.
Mapping 'g' to 'd'.
Example 2:

Input: s = "foo", t = "bar"

Output: false

Explanation:

The strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r'.

The solution i written is 

class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if(s.length() != t.length()) return false;
        unordered_map<char,int> isomorphic;
        unordered_map<char,int> isomorphic_t;
        vector<int>list;
        vector<int>list_t;
        int ms=0, mt=0;
        
        for(int i=0;i<s.length();i++){
            if(isomorphic.find(s[i])==isomorphic.end()){
                isomorphic[s[i]]= ms++;
            }
            if(isomorphic_t.find(t[i])==isomorphic_t.end()){
                isomorphic_t[t[i]]=mt++;
            }
            list.push_back(isomorphic[s[i]]);
            list_t.push_back(isomorphic_t[t[i]]);
        }
        return list == list_t;
    }

};




Problem statement :
Intersection of arrays

and the code i written is 

solution :

class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> setA(nums1.begin(),nums1.end());
        unordered_set<int>result;
        for(int i=0;i<nums2.size();i++){
            if(setA.count(nums2[i])){
                result.insert(nums2[i]);
            }
        }
        return vector<int>(result.begin(),result.end()); // to return answer like oin the form of [] we have to return the vector contating the result 
        
    }
};


2-09-25
Problem statement 

Code
Testcase
Testcase
Test Result
448. Find All Numbers Disappeared in an Array
Solved
Easy
Topics
premium lock icon
Companies
Hint
Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.

 

Example 1:

Input: nums = [4,3,2,7,8,2,3,1]
Output: [5,6]
Example 2:

Input: nums = [1,1]
Output: [2]

the code i written is 
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        unordered_set<int> seen(nums.begin(),nums.end());
        vector<int> result;
        for(int i=1;i<=nums.size();i++){
            if(seen.find(i)==seen.end()){
                result.push_back(i);
            }
        }
        return result;
    }
};

which is taking 44ms of time which is better than hashmaps woith two parameters 



08-09-25
A problem named valid triangle we can solve that using two pointers 

the problem statement and the code i written is 

611. Valid Triangle Number
Solved
Medium
Topics
premium lock icon
Companies
Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.

 

Example 1:

Input: nums = [2,2,3,4]
Output: 3
Explanation: Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
Example 2:


the code i written is 
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        int valid_triangles=0;
        sort(nums.begin(),nums.end());
        for(int k=nums.size()-1;k>=2;k--){
            int i=0, j=k-1;
            while(i<j){
                if(nums[i]+nums[j]>nums[k]){
                    valid_triangles+= (j-i);
                    j--;
                }else{
                    i++;
                }
            }
        }
        return valid_triangles;
        
    }
};



09-09-25
problem statement 

645. Set Mismatch
Solved
Easy
Topics
premium lock icon
Companies
You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.

You are given an integer array nums representing the data status of this set after the error.

Find the number that occurs twice and the number that is missing and return them in the form of an array.



The code that i written for this is 

class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int duplicate=-1, missing=-1;
        vector<int> freq(nums.size()+1,0);   // it will be like n+1 boxes with all zeros
        for(int n:nums){
            freq[n]++;
            if(freq[n]==2) duplicate= n;
        }
        for(int i=1;i<=nums.size();i++){
            if(freq[i]==0){
                missing=i;
                break;
            }
        }
        return {duplicate, missing};

    }
};


Problem statement 

594. Longest Harmonious Subsequence
Solved
Easy
Topics
premium lock icon
Companies
We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.

Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.


The code that i written

class Solution {
public:
    int findLHS(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int largest_seq=0;
        unordered_map<int,int>freq;
        for(int n:nums){
            freq[n]++;
        }
        for(auto& [num,count]:freq){
            if(freq.count(num+1)){
                largest_seq= max(largest_seq, count+freq[num+1]);
            }
        }
        return largest_seq;
    }

};


10-09-25
Problem Statement :


Code


Testcase
Testcase
Test Result
771. Jewels and Stones
Solved
Easy
Topics
premium lock icon
Companies
Hint
You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.

Letters are case sensitive, so "a" is considered a different type of stone from "A".


Approach:

So i silved this question by using hashmaps by finding the frequencies of the second string given in the given question 

the  code that written which beats 100% of users is 

The solution 

class Solution {
public:
    int numJewelsInStones(string jewels, string stones) {
        unordered_map<char,int> freq;
        for(char num:stones){
            freq[num]++;
        }
        int sum=0;
        for(char n:jewels){
            sum+=freq[n];

        }
        return sum;

        
    }
};



13-09-25
Problem statement is 
Finding resltatnt array after removing the anagrams 

2273. Find Resultant Array After Removing Anagrams
Solved
Easy
Topics
premium lock icon
Companies
Hint
You are given a 0-indexed string array words, where words[i] consists of lowercase English letters.

In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words. Keep performing this operation as long as you can select an index that satisfies the conditions.

Return words after performing all operations. It can be shown that selecting the indices for each operation in any arbitrary order will lead to the same result.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, "dacb" is an anagram of "abdc".


the code that written using vector is 

vector<string>result;
        result.push_back(words[0]);
        for(int i=0;i<words.size();i++){
            string first_word= result.back();
            string second_word= words[i];

            string sorted_first= first_word;
            string sorted_second= second_word;
            sort(sorted_first.begin(), sorted_first.end());
            sort(sorted_second.begin(), sorted_second.end());
            if(sorted_first != sorted_second){
                result.push_back(second_word);
            }
            
             

        }
        return result;



        using hashmaps 

        which beats 100%


15-09-25 
Problemn statement 
Most comon word in a string 

So i think the level of the question that the leet code has mentioned was easy but i think its some what greater than easy 
because if you can see first we have to filter the string with out any puncuiations and after getting the modified string getting extracted each word using istringstream and cjecking that is found in banned strings set if not then we have to count the frequencuy and returning the max freq result 

and the solution that i written for this question is 

Solution 

class Solution {
public:
    string mostCommonWord(string paragraph, vector<string>& banned) {
        for(char &ch:paragraph){
            ch= isalpha(ch)? tolower(ch): ' ';
        }
        unordered_set<string> banned_set(banned.begin(), banned.end());
        istringstream iss(paragraph);
        string word , result;
        int max_freq=0;
        unordered_map<string, int> freq;
        while(iss>>word){
            if(banned_set.count(word)){
                continue;
            }
            if(++freq[word]>max_freq){
                max_freq=freq[word];
                result= word;
            }
        }


        return result;
    }
};


which beats 60% of solvers and taking 3ms and by the i taken help of gpt but the idea implenmtation was mine i just taken help from gpt to get correct usage of that istringstream and filtering the modified string 









